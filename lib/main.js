// Generated by CoffeeScript 2.0.1
(function() {
  //###########################################################################################################
  var CND, CODEC, badge, debug, echo, help, rpr;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'KWIC';

  // log                       = CND.get_logger 'plain',     badge
  // info                      = CND.get_logger 'info',      badge
  // whisper                   = CND.get_logger 'whisper',   badge
  // alert                     = CND.get_logger 'alert',     badge
  debug = CND.get_logger('debug', badge);

  // warn                      = CND.get_logger 'warn',      badge
  help = CND.get_logger('help', badge);

  echo = CND.echo.bind(CND);

  //...........................................................................................................
  CODEC = require('hollerith-codec');

  //-----------------------------------------------------------------------------------------------------------
  this.get_factors = function(entry, factorizer = 'characters') {
    factorizer = this._get_factorizer(factorizer);
    return factorizer(entry);
  };

  //-----------------------------------------------------------------------------------------------------------
  this._get_factorizer = function(factorizer = 'characters') {
    var R, type;
    switch (type = CND.type_of(factorizer)) {
      case 'function':
        R = factorizer;
        break;
      case 'text':
        R = this.factorizers[factorizer];
        if (R == null) {
          throw new Error(`unknown factorizer name ${rpr(factorizer)}`);
        }
        break;
      default:
        throw new Error(`illegal factorizer type ${rpr(type)}`);
    }
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.get_weights = function(factors, alphabet = 'unicode') {
    var R, factor, i, len, weight, weighter;
    weighter = this._get_weighter(alphabet);
    R = [];
    for (i = 0, len = factors.length; i < len; i++) {
      factor = factors[i];
      R.push(weight = weighter(factor));
      if (weight === void 0) {
        throw new Error(`factor not in alphabet: ${rpr(factor)}`);
      }
    }
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._get_weighter = function(alphabet = 'unicode') {
    var R, alphabet_pod, type;
    switch (type = CND.type_of(alphabet)) {
      //.......................................................................................................
      case 'function':
        R = alphabet;
        break;
      //.......................................................................................................
      case 'text':
        R = this.alphabets[alphabet];
        if (R == null) {
          throw new Error(`unknown alphabet name ${rpr(alphabet)}`);
        }
        break;
      //.......................................................................................................
      case 'list':
        alphabet_pod = {};
        (function() {
          var factor, i, idx, len, results;
          results = [];
          for (idx = i = 0, len = alphabet.length; i < len; idx = ++i) {
            factor = alphabet[idx];
            results.push(alphabet_pod[factor] = idx);
          }
          return results;
        })();
        R = function(factor) {
          return alphabet[factor];
        };
        break;
      default:
        //.......................................................................................................
        throw new Error(`illegal alphabet type ${rpr(type)}`);
    }
    //.........................................................................................................
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.get_permutations = function(factors, weights, zero = void 0) {
    var R, i, infix, infix_idx, permutation_count, prefix, r_idx, r_weights, ref, suffix;
    R = [];
    if (zero === void 0) {
      zero = null;
    }
    //.........................................................................................................
    weights = weights.slice(0);
    permutation_count = weights.length;
    weights.push(zero);
    for (infix_idx = i = 0, ref = permutation_count; 0 <= ref ? i < ref : i > ref; infix_idx = 0 <= ref ? ++i : --i) {
      prefix = factors.slice(0, infix_idx);
      infix = factors[infix_idx];
      suffix = factors.slice(infix_idx + 1);
      /* Here we reverse the order of weights in the 'suffix' part of the weights (the part that comes
      behind the guard value); this means that both prefix and suffix weights that are closer to the
      infix have a stronger influence on the sorting than those that are farther away. */
      r_idx = permutation_count - infix_idx;
      r_weights = weights.slice(0, +r_idx + 1 || 9e9).concat(weights.slice(r_idx + 1).reverse());
      R.push([r_weights, infix, suffix, prefix]);
      //.....................................................................................................
      // weights   = weights[ .. ]
      this._rotate_left(weights);
    }
    //.........................................................................................................
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.permute = function(entry, settings) {
    var alphabet, factorizer, factors, ref, ref1, ref2, weights, zero;
    factorizer = (ref = settings != null ? settings['factorizer'] : void 0) != null ? ref : void 0;
    alphabet = (ref1 = settings != null ? settings['alphabet'] : void 0) != null ? ref1 : void 0;
    zero = (ref2 = settings != null ? settings['zero'] : void 0) != null ? ref2 : void 0;
    factors = this.get_factors(entry, factorizer);
    weights = this.get_weights(factors, alphabet);
    return this.get_permutations(factors, weights, zero);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.sort = function(collection) {
    var _, bkey, entry, facets, i, infix, j, key, len, len1, permutations, prefix, suffix;
    facets = [];
    //.........................................................................................................
    for (i = 0, len = collection.length; i < len; i++) {
      [permutations, entry] = collection[i];
      for (j = 0, len1 = permutations.length; j < len1; j++) {
        key = permutations[j];
        bkey = CODEC.encode(key);
        facets.push([bkey, key, entry]);
      }
    }
    facets.sort(function(a, b) {
      return a[0].compare(b[0]);
    });
    return (function() {
      var k, len2, results;
      results = [];
      for (k = 0, len2 = facets.length; k < len2; k++) {
        [_, [_, infix, suffix, prefix], entry] = facets[k];
        //.........................................................................................................
        results.push([prefix, infix, suffix, entry]);
      }
      return results;
    })();
  };

  //-----------------------------------------------------------------------------------------------------------
  this.report = function(collection, settings) {
    var _, entry, i, infix, j, joiner, k, l, len, len1, len2, len3, len4, length, lineups_and_entries, m, max_length, n, o, padder, part, prefix, prefix_length, ref, ref1, ref2, ref3, ref4, separator, show, suffix, suffix_length;
    padder = (ref = settings != null ? settings['padder'] : void 0) != null ? ref : ' ';
    separator = (ref1 = settings != null ? settings['separator'] : void 0) != null ? ref1 : '|';
    joiner = (ref2 = settings != null ? settings['joiner'] : void 0) != null ? ref2 : '';
    show = process.stdout.isTTY ? help : echo;
    //.........................................................................................................
    lineups_and_entries = this.sort(collection);
    //.........................................................................................................
    max_length = -2e308;
    for (i = 0, len = lineups_and_entries.length; i < len; i++) {
      [prefix, infix, suffix, entry] = lineups_and_entries[i];
      length = infix.length;
      for (j = 0, len1 = prefix.length; j < len1; j++) {
        part = prefix[j];
        length += part.length;
      }
      max_length = Math.max(max_length, length);
    }
    //.........................................................................................................
    for (k = 0, len2 = lineups_and_entries.length; k < len2; k++) {
      [prefix, infix, suffix, entry] = lineups_and_entries[k];
      prefix = prefix.slice(0);
      suffix = suffix.slice(0);
      prefix_length = 0;
      for (l = 0, len3 = prefix.length; l < len3; l++) {
        part = prefix[l];
        prefix_length += part.length;
      }
      suffix_length = 0;
      for (m = 0, len4 = suffix.length; m < len4; m++) {
        part = suffix[m];
        suffix_length += part.length;
      }
      for (_ = n = 0, ref3 = max_length - prefix_length; n < ref3; _ = n += +1) {
        prefix.unshift(padder);
      }
      for (_ = o = 0, ref4 = max_length - (suffix_length + infix.length); o < ref4; _ = o += +1) {
        // debug 'Â©L9201', entry, infix, suffix
        suffix.push(padder);
      }
      prefix = prefix.join(joiner);
      suffix = suffix.join(joiner);
      entry = CND.isa_text(entry) ? entry : rpr(entry);
      show(prefix + separator + infix + suffix + padder + entry);
    }
    //.........................................................................................................
    return null;
  };

  //===========================================================================================================
  // FACTORIZERS AND ALPHABETS
  //-----------------------------------------------------------------------------------------------------------
  this.factorizers = {
    'characters': function(text) {
      return Array.from(text);
    },
    'syllables': function(text) {
      return text.split('-');
    }
  };

  //-----------------------------------------------------------------------------------------------------------
  this.alphabets = {
    'unicode': function(factor) {
      return factor.codePointAt(0);
    }
  };

  //===========================================================================================================
  // HELPERS
  //-----------------------------------------------------------------------------------------------------------
  this._rotate_left = function(list) {
    if (list.length < 2) {
      return list;
    }
    list.push(list.shift());
    return list;
  };

  // #-----------------------------------------------------------------------------------------------------------
// @_rotate_right = ( list ) ->
//   return list if list.length < 2
//   list.unshift list.pop()
//   return list

}).call(this);

//# sourceMappingURL=main.js.map
